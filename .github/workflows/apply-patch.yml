name: Apply Self-Hosted UI Patch

# TEMPORARY WORKFLOW - DELETE AFTER SUCCESSFUL PATCH APPLICATION
on:
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Target branch (main/testing)'
        required: true
        default: 'main'
        type: choice
        options: [main, testing]
      create_pr:
        description: 'Create PR instead of direct commit?'
        required: true
        default: false
        type: boolean
      dry_run:
        description: 'Dry run?'
        required: false
        default: false
        type: boolean

jobs:
  apply-patch:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: ðŸ“¥ Checkout testing branch
        uses: actions/checkout@v4
        with:
          ref: testing
          fetch-depth: 0
      
      - name: ðŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: ðŸŽ¯ Apply Patch Surgically
        id: apply
        run: |
          TARGET_FILE="_worker.js"
          PATCH_FILE="self-hosted-ui.patch"
          
          cat > apply_patch.cjs << 'EOFJS'
          const fs = require('fs');
          const targetFile = process.argv[2];
          const patchFile = process.argv[3];
          
          let workerCode = fs.readFileSync(targetFile, 'utf8');
          const patchContent = fs.readFileSync(patchFile, 'utf8');
          
          console.log("ðŸ› ï¸  Extracting functions from STEP 1...");
          const funcStartMark = 'function handleSubPage';
          const startIdx = patchContent.indexOf(funcStartMark);
          if (startIdx === -1) throw new Error("Could not find STEP 1 functions");
          
          // Find the NEXT closing code block after the functions start
          const endIdx = patchContent.indexOf('```', startIdx);
          const newFunctions = patchContent.substring(startIdx, endIdx).trim();
          console.log(`âœ… Extracted ${newFunctions.length} characters of JS code`);

          // Find insertion point (before export default)
          const exportMatch = workerCode.match(/^export default \{/m);
          if (!exportMatch) throw new Error("Could not find insertion point");
          
          // Clean existing if repeat run
          if (workerCode.includes('function handleSubPage')) {
            workerCode = workerCode.replace(/\/\/ ={40,}[\s\S]*?(?=export default \{)/, '');
          }

          const insertIdx = workerCode.match(/^export default \{/m).index;
          workerCode = workerCode.substring(0, insertIdx) + 
                       "// ============================================\n" +
                       "// SELF-HOSTED SUB PAGE FUNCTIONS\n" +
                       "// ============================================\n\n" +
                       newFunctions + "\n\n" + 
                       workerCode.substring(insertIdx);

          console.log("ðŸ› ï¸  Replacing redirect logic...");
          // Pattern yang lebih aman: nyari block startsWith("/sub") sampai penutup block if-nya
          // Kita pakai string replacement yang spesifik karena formatnya konstan
          const oldLogic = 'if (url.pathname.startsWith("/sub")) {\n        return Response.redirect(SUB_PAGE_URL + `?host=${APP_DOMAIN}`, 301);\n      }';
          const newLogic = 'if (url.pathname.startsWith("/sub")) {\n        return handleSubPage(url, env);\n      }';
          
          if (workerCode.includes(oldLogic)) {
            workerCode = workerCode.replace(oldLogic, newLogic);
            console.log("âœ… Successfully replaced redirect logic");
          } else {
            console.warn("âš ï¸  Exact match failed, trying fuzzy regex...");
            const fuzzyPattern = /if\s*\(url\.pathname\.startsWith\("\/sub"\)\)\s*\{[\s\S]*?return\s+Response\.redirect\([\s\S]*?\);\s*\}/;
            if (fuzzyPattern.test(workerCode)) {
              workerCode = workerCode.replace(fuzzyPattern, newLogic);
              console.log("âœ… Fuzzy match replaced the logic");
            } else {
              throw new Error("Could not find redirect logic to replace");
            }
          }

          fs.writeFileSync(targetFile, workerCode);
          EOFJS
          
          node apply_patch.cjs "$TARGET_FILE" "$PATCH_FILE"

      - name: ðŸ§ª Syntax Validation
        run: node -c _worker.js

      - name: ðŸ”€ Commit and Push
        if: github.event.inputs.dry_run != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          TARGET_BRANCH="${{ github.event.inputs.target_branch }}"
          git fetch origin "$TARGET_BRANCH"
          
          if [ "${{ github.event.inputs.create_pr }}" = "true" ]; then
            BRANCH_NAME="fix/self-hosted-ui-$(date +%s)"
            git checkout -b "$BRANCH_NAME" "origin/$TARGET_BRANCH"
            git add _worker.js
            git commit -m "feat(ui): fix self-hosted UI injection logic"
            git push origin "$BRANCH_NAME"
            echo "PR_REQUIRED=true" >> $GITHUB_ENV
            echo "BNAME=$BRANCH_NAME" >> $GITHUB_ENV
          else
            git checkout "$TARGET_BRANCH"
            git checkout testing -- _worker.js
            # Re-apply patch in the target branch context just to be safe
            node apply_patch.cjs _worker.js self-hosted-ui.patch
            git add _worker.js
            git commit -m "feat(ui): apply self-hosted UI generator"
            git push origin "$TARGET_BRANCH"
          fi

      - name: ðŸ“¬ Create PR
        if: env.PR_REQUIRED == 'true'
        env: { GH_TOKEN: "${{ secrets.GITHUB_TOKEN }}" }
        run: |
          gh pr create --base "${{ github.event.inputs.target_branch }}" --head "$BNAME" \
            --title "ðŸŽ¨ fix(ui): Self-hosted UI Generator" \
            --body "Fixed injection logic that previously caused syntax errors."
