name: Apply Self-Hosted UI Patch

# TEMPORARY WORKFLOW - DELETE AFTER SUCCESSFUL PATCH APPLICATION
# Purpose: Apply self-hosted-ui.patch to _worker.js and commit to main branch
# Location: This workflow is in MAIN branch, patch file is in TESTING branch

on:
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Target branch untuk commit (main/testing)'
        required: true
        default: 'main'
        type: choice
        options:
          - main
          - testing
      create_pr:
        description: 'Create Pull Request instead of direct commit?'
        required: true
        default: false
        type: boolean
      dry_run:
        description: 'Dry run (test tanpa commit)'
        required: false
        default: false
        type: boolean
      apply_to_file:
        description: 'File target untuk patch'
        required: false
        default: '_worker.js'
        type: string

jobs:
  apply-patch:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: üì• Checkout testing branch
        uses: actions/checkout@v4
        with:
          ref: testing
          fetch-depth: 0
      
      - name: üîç Verify patch file exists
        run: |
          if [ ! -f "self-hosted-ui.patch" ]; then
            echo "‚ùå Error: self-hosted-ui.patch not found!"
            exit 1
          fi
          echo "‚úÖ Patch file found"
          echo "üìÑ Patch file size: $(wc -c < self-hosted-ui.patch) bytes"
      
      - name: üîç Verify target file exists
        run: |
          TARGET_FILE="${{ github.event.inputs.apply_to_file }}"
          if [ ! -f "$TARGET_FILE" ]; then
            echo "‚ùå Error: $TARGET_FILE not found!"
            exit 1
          fi
          echo "‚úÖ Target file found: $TARGET_FILE"
          echo "üìÑ Original size: $(wc -c < $TARGET_FILE) bytes"
          cp "$TARGET_FILE" "${TARGET_FILE}.backup"
          echo "üíæ Backup created: ${TARGET_FILE}.backup"
      
      - name: üîß Setup Node.js for validation
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: üéØ Parse and apply patch
        id: apply
        run: |
          TARGET_FILE="${{ github.event.inputs.apply_to_file }}"
          PATCH_FILE="self-hosted-ui.patch"
          
          echo "üîÑ Starting patch application..."
          
          cat > apply_patch.js << 'EOFJS'
          const fs = require('fs');
          const targetFile = process.argv[2];
          const patchFile = process.argv[3];
          
          console.log(`üìñ Target: ${targetFile}, Patch: ${patchFile}`);
          let workerCode = fs.readFileSync(targetFile, 'utf8');
          const patchContent = fs.readFileSync(patchFile, 'utf8');
          
          // Improved function extraction: Look for everything between handleSubPage and the end of the script block
          const functionStart = patchContent.indexOf('function handleSubPage');
          const lastIndex = patchContent.lastIndexOf('}');
          const functionEnd = patchContent.indexOf('```', lastIndex);
          
          if (functionStart === -1 || lastIndex === -1) {
            console.error('‚ùå Could not find function start or end in patch');
            process.exit(1);
          }
          
          const newFunctions = patchContent.substring(functionStart, (functionEnd !== -1 ? functionEnd : patchContent.length)).trim();
          console.log(`‚úÖ Extracted functions (${newFunctions.length} chars)`);
          
          // Find insertion point
          const exportMatch = workerCode.match(/^export default \{/m);
          if (!exportMatch) {
            console.error('‚ùå Could not find "export default {" in worker code');
            process.exit(1);
          }
          
          // Cleanup existing if present
          if (workerCode.includes('function handleSubPage(')) {
            console.log('‚ö†Ô∏è  Existing handleSubPage found, cleaning up...');
            workerCode = workerCode.replace(/\/\/ ={40,}\n\/\/ SELF-HOSTED SUB PAGE[\s\S]*?(?=^export default \{)/m, '');
          }
          
          // Insert new functions
          const insertIndex = workerCode.match(/^export default \{/m).index;
          const updatedCode = workerCode.substring(0, insertIndex) + 
            '// ' + '='.repeat(44) + '\n' +
            '// SELF-HOSTED SUB PAGE WITH CONFIG GENERATOR\n' +
            '// ' + '='.repeat(44) + '\n\n' +
            newFunctions + '\n\n' +
            workerCode.substring(insertIndex);
          
          // Robust redirect logic replacement
          // Match the entire "if (url.pathname.startsWith("/sub")) { ... }" block
          const redirectPattern = /if\s*\(url\.pathname\.startsWith\("\/sub"\)\)\s*\{[\s\S]*?return\s+Response\.redirect\([\s\S]*?\);\s*\}/;
          const newLogic = `if (url.pathname.startsWith("/sub")) {\n    return handleSubPage(url, env);\n  }`;
          
          if (redirectPattern.test(updatedCode)) {
            const finalCode = updatedCode.replace(redirectPattern, newLogic);
            console.log('‚úÖ Successfully replaced redirect logic');
            fs.writeFileSync(targetFile, finalCode, 'utf8');
            
            fs.writeFileSync('patch_stats.txt', `original_size=${workerCode.length}\npatched_size=${finalCode.length}\ndiff=${finalCode.length - workerCode.length}\n`);
          } else {
            console.error('‚ùå Could not find redirect logic block to replace');
            // Log a snippet for debugging
            const subIndex = updatedCode.indexOf('pathname.startsWith("/sub")');
            if (subIndex !== -1) {
              console.log('üîç Snippet found:', updatedCode.substring(subIndex - 20, subIndex + 100));
            }
            process.exit(1);
          }
          EOFJS
          
          node apply_patch.js "$TARGET_FILE" "$PATCH_FILE"
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Patch applied successfully!"
            if [ -f "patch_stats.txt" ]; then
              source patch_stats.txt
              echo "original_size=$original_size" >> $GITHUB_OUTPUT
              echo "patched_size=$patched_size" >> $GITHUB_OUTPUT
              echo "diff=$diff" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ùå Patch application failed!"
            mv "${TARGET_FILE}.backup" "$TARGET_FILE"
            exit 1
          fi
      
      - name: üß™ Validate Result
        run: |
          TARGET_FILE="${{ github.event.inputs.apply_to_file }}"
          echo "üîç Validating output..."
          
          # Syntax check
          node -c "$TARGET_FILE"
          if [ $? -ne 0 ]; then
            echo "‚ùå Syntax error detected in patched file!"
            exit 1
          fi
          echo "‚úÖ JavaScript syntax is valid"
          
          # Logic check
          if grep -q "function handleSubPage" "$TARGET_FILE" && grep -q "return handleSubPage(url, env)" "$TARGET_FILE"; then
            echo "‚úÖ Patch verified: Functions and redirect logic present"
          else
            echo "‚ùå Patch verification failed: Missing required code!"
            exit 1
          fi
      
      - name: üîÄ Commit and Push
        if: github.event.inputs.dry_run != 'true'
        run: |
          TARGET_BRANCH="${{ github.event.inputs.target_branch }}"
          TARGET_FILE="${{ github.event.inputs.apply_to_file }}"
          
          git fetch origin "$TARGET_BRANCH"
          
          if [ "${{ github.event.inputs.create_pr }}" = "true" ]; then
            BRANCH_NAME="feat/self-hosted-ui-$(date +%s)"
            git checkout -b "$BRANCH_NAME" "origin/$TARGET_BRANCH"
            echo "branch_name=$BRANCH_NAME" >> $GITHUB_ENV
          else
            git checkout "$TARGET_BRANCH"
          fi
          
          # Copy patched file from testing context to target branch
          git checkout testing -- "$TARGET_FILE"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "$TARGET_FILE"
          git commit -m "feat(ui): apply self-hosted config generator patch" -m "Self-hosted HTML interface added to replacement of external redirect."
          
          if [ "${{ github.event.inputs.create_pr }}" = "true" ]; then
            git push origin "$BRANCH_NAME"
            echo "PR_CREATION_REQUIRED=true" >> $GITHUB_ENV
          else
            git push origin "$TARGET_BRANCH"
            echo "‚úÖ Successfully pushed to $TARGET_BRANCH"
          fi

      - name: üì¨ Create Pull Request
        if: env.PR_CREATION_REQUIRED == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr create \
            --base "${{ github.event.inputs.target_branch }}" \
            --head "${{ env.branch_name }}" \
            --title "üé® feat(ui): Self-hosted config generator" \
            --body "Applied self-hosted UI patch via CI workflow." \
            --label "enhancement,automated"
