name: Network Benchmark

on:
  schedule:
    - cron: '*/30 * * * *'
  workflow_dispatch:

jobs:
  benchmark:
    name: Network Performance Test
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: testing
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Run Benchmark Tests
        run: |
          node << 'EOF'
          const https = require('https');
          const http = require('http');
          const fs = require('fs');
          
          const DOMAINS = [
            'hoshiyomi.qzz.io',
            'hoshiyomi.web.id',
            'belajar.ruangguru.com.hoshiyomi.qzz.io',
            'api24-normal.tiktokv.com.hoshiyomi.qzz.io'
          ];
          
          function request(url) {
            return new Promise((resolve, reject) => {
              const protocol = url.startsWith('https') ? https : http;
              const start = Date.now();
              
              protocol.get(url, (res) => {
                let data = '';
                let size = 0;
                
                res.on('data', chunk => {
                  data += chunk;
                  size += chunk.length;
                });
                
                res.on('end', () => {
                  const duration = Date.now() - start;
                  resolve({ duration, size, data, status: res.statusCode });
                });
              }).on('error', reject);
            });
          }
          
          async function testPing(domain) {
            const results = [];
            
            for (let i = 0; i < 10; i++) {
              try {
                const { duration } = await request(`https://${domain}/api/v1/myip`);
                results.push(duration);
              } catch (err) {
                results.push(-1);
              }
            }
            
            const valid = results.filter(r => r > 0);
            const avg = valid.length > 0 ? Math.round(valid.reduce((a,b) => a+b, 0) / valid.length) : -1;
            
            return { avg_latency_ms: avg, samples: valid.length };
          }
          
          async function testDownload(domain) {
            try {
              const { duration, size } = await request(
                `https://${domain}/api/v1/sub?cc=US,SG,JP&limit=100&format=raw`
              );
              
              const sizeKB = (size / 1024).toFixed(2);
              const speedKBs = ((size / 1024) / (duration / 1000)).toFixed(2);
              
              return {
                size_kb: parseFloat(sizeKB),
                speed_kbs: parseFloat(speedKBs),
                duration_ms: duration
              };
            } catch (err) {
              return { error: err.message };
            }
          }
          
          async function testVideoStream(domain) {
            const chunks = 5;
            let successChunks = 0;
            let totalTime = 0;
            let bufferStalls = 0;
            
            for (let i = 0; i < chunks; i++) {
              try {
                const { duration } = await request(
                  `https://${domain}/api/v1/sub?cc=US&limit=50`
                );
                
                totalTime += duration;
                successChunks++;
                
                if (duration > 2000) bufferStalls++;
                
                await new Promise(r => setTimeout(r, 100));
              } catch (err) {
                // Skip
              }
            }
            
            const avgChunkTime = successChunks > 0 ? Math.round(totalTime / successChunks) : -1;
            const quality = bufferStalls === 0 ? 'smooth' : bufferStalls <= 1 ? 'acceptable' : 'poor';
            
            return {
              avg_chunk_time_ms: avgChunkTime,
              buffer_stalls: bufferStalls,
              quality: quality,
              success_rate: ((successChunks / chunks) * 100).toFixed(2)
            };
          }
          
          async function testVoiceCall(domain) {
            const packets = 30;
            const interval = 100;
            
            let successPackets = 0;
            let latencies = [];
            let jitter = [];
            
            for (let i = 0; i < packets; i++) {
              try {
                const { duration } = await request(`https://${domain}/api/v1/myip`);
                
                latencies.push(duration);
                successPackets++;
                
                if (latencies.length > 1) {
                  const prevLatency = latencies[latencies.length - 2];
                  jitter.push(Math.abs(duration - prevLatency));
                }
                
                await new Promise(r => setTimeout(r, interval));
              } catch (err) {
                // Dropped
              }
            }
            
            const avgLatency = latencies.length > 0 ? Math.round(latencies.reduce((a,b) => a+b, 0) / latencies.length) : -1;
            const maxLatency = latencies.length > 0 ? Math.max(...latencies) : -1;
            const avgJitter = jitter.length > 0 ? Math.round(jitter.reduce((a,b) => a+b, 0) / jitter.length) : -1;
            const packetLoss = ((packets - successPackets) / packets * 100).toFixed(2);
            
            let callQuality;
            if (avgLatency < 150 && avgJitter < 30 && parseFloat(packetLoss) < 1) {
              callQuality = 'excellent';
            } else if (avgLatency < 300 && avgJitter < 50 && parseFloat(packetLoss) < 3) {
              callQuality = 'good';
            } else if (avgLatency < 400 && parseFloat(packetLoss) < 5) {
              callQuality = 'acceptable';
            } else {
              callQuality = 'poor';
            }
            
            return {
              avg_latency_ms: avgLatency,
              max_latency_ms: maxLatency,
              avg_jitter_ms: avgJitter,
              packet_loss_percent: parseFloat(packetLoss),
              call_quality: callQuality
            };
          }
          
          async function runBenchmark() {
            console.log('Starting benchmark');
            
            const results = {};
            
            for (const domain of DOMAINS) {
              console.log(`Testing ${domain}`);
              const ping = await testPing(domain);
              const download = await testDownload(domain);
              const video = await testVideoStream(domain);
              const voice = await testVoiceCall(domain);
              results[domain] = { ping, download, video, voice };
            }
            
            const timestamp = new Date().toISOString();
            let log = '\n' + '='.repeat(76) + '\n';
            log += 'BENCHMARK RESULTS\n';
            log += 'Timestamp: ' + timestamp + '\n';
            log += '='.repeat(76) + '\n';
            
            for (const [domain, data] of Object.entries(results)) {
              log += '\nDomain: ' + domain + '\n';
              log += '  Ping: ' + data.ping.avg_latency_ms + 'ms\n';
              
              if (data.download.error) {
                log += '  Download: ERROR\n';
              } else {
                log += '  Download: ' + data.download.speed_kbs + ' KB/s\n';
              }
              
              log += '  Video: ' + data.video.quality + '\n';
              log += '  Voice: ' + data.voice.call_quality + '\n';
            }
            
            log += '\n';
            fs.appendFileSync('benchmark.log', log);
            console.log('Done');
          }
          
          runBenchmark().catch(console.error);
          EOF
      
      - name: Purge Old Entries
        run: |
          node << 'EOF'
          const fs = require('fs');
          if (!fs.existsSync('benchmark.log')) process.exit(0);
          const content = fs.readFileSync('benchmark.log', 'utf8');
          const sep = '=' + '='.repeat(75);
          const entries = content.split(sep).filter(e => e.trim());
          console.log('Entries: ' + entries.length);
          if (entries.length > 10) {
            const keep = entries.slice(-10);
            fs.writeFileSync('benchmark.log', keep.map(e => sep + e).join(''));
            console.log('Purged ' + (entries.length - 10));
          }
          EOF
      
      - name: Commit Results
        run: |
          git config user.name github-actions[bot]
          git config user.email github-actions[bot]@users.noreply.github.com
          git add benchmark.log
          if ! git diff --staged --quiet; then
            git commit -m "benchmark [skip ci]"
            git push
          fi
